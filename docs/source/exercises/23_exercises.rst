.. meta::
   :http-equiv=Content-Type: text/html; charset=utf-8

.. raw:: latex

   \newpage

Задания
=======

.. include:: ./exercises_intro.rst

Задание 23.1
~~~~~~~~~~~~

В этом задании необходимо создать класс IPAddress.

При создании экземпляра класса, как аргумент передается IP-адрес и маска,
а также должна выполняться проверка корректности адреса и маски:

Адрес считается корректно заданным, если он:

  * состоит из 4 чисел разделенных точкой
  * каждое число в диапазоне от 0 до 255

Маска считается корректной, если это число в диапазоне от 8 до 32 включительно

Если маска или адрес не прошли проверку, необходимо сгенерировать исключение ValueError с соответствующим текстом (вывод ниже).

Также, при создании класса, должны быть созданы две переменных экземпляра: ip и mask, в которых содержатся адрес и маска, соответственно.

Пример создания экземпляра класса:

.. code:: python

    In [1]: ip = IPAddress('10.1.1.1/24')

    Атрибуты ip и mask
    In [2]: ip1 = IPAddress('10.1.1.1/24')

    In [3]: ip1.ip
    Out[3]: '10.1.1.1'

    In [4]: ip1.mask
    Out[4]: 24

Проверка корректности адреса (traceback сокращен)

.. code:: python
    In [5]: ip1 = IPAddress('10.1.1/24')
    ---------------------------------------------------------------------------
    ...
    ValueError: Incorrect IPv4 address

Проверка корректности маски (traceback сокращен)

.. code:: python

    In [6]: ip1 = IPAddress('10.1.1.1/240')
    ---------------------------------------------------------------------------
    ...
    ValueError: Incorrect mask

Задание 23.1a
~~~~~~~~~~~~~

Скопировать и изменить класс IPAddress из задания 23.1.

Добавить два строковых представления для экземпляров класса IPAddress.
Как дожны выглядеть строковые представления, надо определить из вывода ниже:

Создание экземпляра

.. code:: python

    In [5]: ip1 = IPAddress('10.1.1.1/24')

    In [6]: str(ip1)
    Out[6]: 'IP address 10.1.1.1/24'

    In [7]: print(ip1)
    IP address 10.1.1.1/24

    In [8]: ip1
    Out[8]: IPAddress('10.1.1.1/24')

    In [9]: ip_list = []

    In [10]: ip_list.append(ip1)

    In [11]: ip_list
    Out[11]: [IPAddress('10.1.1.1/24')]

    In [12]: print(ip_list)
    [IPAddress('10.1.1.1/24')]

Задание 23.2
~~~~~~~~~~~~

Скопировать класс CiscoTelnet из любого задания 22.2x и добавить классу поддержку
работы в менеджере контекста.
При выходе из блока менеджера контекста должно закрываться соединение.

Пример работы:

.. code:: python

    In [14]: r1_params = {
        ...:     'ip': '192.168.100.1',
        ...:     'username': 'cisco',
        ...:     'password': 'cisco',
        ...:     'secret': 'cisco'}

    In [15]: from task_23_2 import CiscoTelnet

    In [16]: with CiscoTelnet(**r1_params) as r1:
        ...:     print(r1.send_show_command('sh clock'))
        ...:
    sh clock
    *19:17:20.244 UTC Sat Apr 6 2019
    R1#

    In [17]: with CiscoTelnet(**r1_params) as r1:
        ...:     print(r1.send_show_command('sh clock'))
        ...:     raise ValueError('Возникла ошибка')
        ...:
    sh clock
    *19:17:38.828 UTC Sat Apr 6 2019
    R1#
    ---------------------------------------------------------------------------
    ValueError                                Traceback (most recent call last)
    <ipython-input-17-f3141be7c129> in <module>
          1 with CiscoTelnet(**r1_params) as r1:
          2     print(r1.send_show_command('sh clock'))
    ----> 3     raise ValueError('Возникла ошибка')
          4

    ValueError: Возникла ошибка


Задание 23.3
~~~~~~~~~~~~

Скопировать и изменить класс Topology из задания 22.1x.

Добавить метод, который позволит выполнять сложение двух экземпляров класса Topology.
В результате сложения должен возвращаться новый экземпляр класса Topology.

Создание двух топологий:

.. code:: python

    In [1]: t1 = Topology(topology_example)

    In [2]: t1.topology
    Out[2]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

    In [3]: topology_example2 = {('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
                                 ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}

    In [4]: t2 = Topology(topology_example2)

    In [5]: t2.topology
    Out[5]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}

Суммирование топологий:

.. code:: python

    In [6]: t3 = t1+t2

    In [7]: t3.topology
    Out[7]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R1', 'Eth0/4'): ('R7', 'Eth0/0'),
     ('R1', 'Eth0/6'): ('R9', 'Eth0/0'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

Проверка, что исходные топологии не изменились

.. code:: python

    In [9]: t1.topology
    Out[9]:
    {('R1', 'Eth0/0'): ('SW1', 'Eth0/1'),
     ('R2', 'Eth0/0'): ('SW1', 'Eth0/2'),
     ('R2', 'Eth0/1'): ('SW2', 'Eth0/11'),
     ('R3', 'Eth0/0'): ('SW1', 'Eth0/3'),
     ('R3', 'Eth0/1'): ('R4', 'Eth0/0'),
     ('R3', 'Eth0/2'): ('R5', 'Eth0/0')}

    In [10]: t2.topology
    Out[10]: {('R1', 'Eth0/4'): ('R7', 'Eth0/0'), ('R1', 'Eth0/6'): ('R9', 'Eth0/0')}


Задание 23.3a
~~~~~~~~~~~~~

В этом задании надо сделать так, чтобы экземпляры класса Topology были итерируемыми объектами.
Основу класса Topology можно взять из любого задания 22.1x или задания 23.3.

После создания экземпляра класса, экземпляр должен работать как итерируемый объект.
На каждой итерации должен возвращаться кортеж, который описывает одно соединение.


Пример работы класса:

.. code:: python

    In [1]: top = Topology(topology_example)

    In [2]: for link in top:
       ...:     print(link)
       ...:
    (('R1', 'Eth0/0'), ('SW1', 'Eth0/1'))
    (('R2', 'Eth0/0'), ('SW1', 'Eth0/2'))
    (('R2', 'Eth0/1'), ('SW2', 'Eth0/11'))
    (('R3', 'Eth0/0'), ('SW1', 'Eth0/3'))
    (('R3', 'Eth0/1'), ('R4', 'Eth0/0'))
    (('R3', 'Eth0/2'), ('R5', 'Eth0/0'))


Проверить работу класса.
